Stored Procedure/Tárolt eljárás
	-> ezek az adatbázishoz kapcsolódnak

Trigger, ami a táblához kapcsolódik, hogy a DML=data manipulating language utasításai: INSERT INTO, UPDATE, DELETE 
esetén bizonyos automatizmusokat érvényesítsen.

XAMPP: virtuális web- és tartalomszolgáló (ami a localhost-on működik, ennek IPv4 címe: 127.0.0.0/8 tartományból származik,
általában 127.0.0.1/255.0.0.0)

az Apache webszerver a külvilág számára elérhető: http - 80, https - 443 port-okon (vagyis van a webszervernek egy 
publikus IPv4 címe és a kliensek ezt "célozzák meg" az említett port-ok valamelyikén /https un. biztonságos kapcsolatot biztosít, 
ami egy tanusítvánnyal hitelesített két kulcsos: nyílvános és titkos, titkosítást használva garantálja, hogy a kliens-szerver gépeken túl,
más ne férhessen érdemben a kommunikációs csatornán közvetített tartalmakhoz)

a MySQL adatbázis szerver a külvilág számáraközvetlenül nem hozzáférhető az adatbiztonság megteremtése miatt.

A jelzett problémák a webszerveren működő webalkalmazások révén lesznek áthidalhatók: backend. 
Esetünkben egy ilyen szerveroldali program a phpmyadmin, ami garantálja, 
hogy egy webböngészőben legyen lehetőségük a frontend-nek mondott, interaktív programmal, adatmanipulációkat végezni.



Szükségünk lesz egy adatbázisra:

CREATE DATABASE sppeldak CHARSET utf8 COLLATE utf8_general_ci;


DELIMITER $$
CREATE PROCEDURE elso()
BEGIN
	SELECT "(c) 2024. Ritzl Bence", RAND();
END$$
DELIMITER ;


Kipróbálása: CALL elso()

Noha eljárások kategória megjelenik az adatbázisunk alárendeltjeként, a tényleges nyílvántartásba vétel, ami a használhatóság alapja a mysql rendszeradatbázis, proc nevezetű táblájában történik meg.

Semelyik CREATE nem képes arra, hogy ugyanazt a tartalmat többször is létrehozza. Így van ez a CREATE PROCEDURE-rel is. Emiatt a tárolt eljárás, függvény és trigger-ek kódjait, érdemes a DROP PROCEDURE 	utasítással kezdeni, hogy előbb eltakarítsuk a korábbi tartalmat és utána létrehozhassuk az újat.


DROP PROCEDURE IF EXISTS elso;
DELIMITER $$
CREATE PROCEDURE elso()
BEGIN
	SELECT "(c) 2024. Ritzl Bence", RAND();
END$$
DELIMITER ;


DROP PROCEDURE IF EXISTS lottostatisztika;
DELIMITER //
CREATE PROCEDURE lottostatisztika()
BEGIN
	# DEKLARÁCIÓK
	DECLARE lsz INT;
	-- FUNKCIONALITÁS
	SET lsz=FLOOR(RAND()*90+1);
	SELECT lsz; 	

END//
DELIMITER ;




Mivel nincs tömbünk, helyette használjunk táblát.

CREATE TABLE tippek(szam INT PRIMARY KEY);

Mivel az elsődlges kulcs garantálja az egyediséget, így újabb probléma merül fel amiatt, hogy az érték többször is előfordulhat.

KIVÉTEL vs. HIBA
(Minden hiba kivétel, de nem minden kivétel hiba = a rendellenességek nem feltétlenül kell, hogy végzetesek legyenek)



DROP PROCEDURE IF EXISTS lottostatisztika;
DELIMITER //
CREATE PROCEDURE lottostatisztika()
BEGIN
	# DEKLARÁCIÓK
	-- 1. változók
	DECLARE lsz INT;
	-- 2. a lekérdezésekhez kapcsolódó CURSOR-ok
	-- 3. kivételkezeléshez tartozó deklarációkat tartalmazza
	DECLARE CONTINUE HANDLER FOR 1062 SELECT "Ez már szerepel", lsz;
	-- FUNKCIONALITÁS
	CREATE TABLE tippek(szam INT PRIMARY KEY);
	SET lsz=FLOOR(RAND()*90+1);
	INSERT INTO tippek VALUES(lsz);
	SET lsz=FLOOR(RAND()*90+1);
	INSERT INTO tippek VALUES(lsz);
	SET lsz=FLOOR(RAND()*90+1);
	INSERT INTO tippek VALUES(lsz);
	SET lsz=FLOOR(RAND()*90+1);
	INSERT INTO tippek VALUES(lsz);
	SET lsz=FLOOR(RAND()*90+1);
	INSERT INTO tippek VALUES(lsz);
	SELECT * FROM tippek;
	DROP TABLE tippek;	

END//
DELIMITER ;



----------------------------------------------------------------------------------------------------------------------




DROP PROCEDURE IF EXISTS lottostatisztika;
DELIMITER //
CREATE PROCEDURE lottostatisztika()
BEGIN
	# DEKLARÁCIÓK
	-- 1. változók
	DECLARE i INT DEFAULT 1;
	DECLARE lsz INT;
	-- 2. a lekérdezésekhez kapcsolódó CURSOR-ok
	-- 3. kivételkezeléshez tartozó deklarációkat tartalmazza
	DECLARE CONTINUE HANDLER FOR 1062 SET i=i-1;
	-- FUNKCIONALITÁS
	CREATE TABLE tippek(szam INT PRIMARY KEY);
	WHILE i<=5 DO
		SET lsz=FLOOR(RAND()*90+1);
		INSERT INTO tippek VALUES(lsz);
		SET i=i+1;
	END WHILE;
	SELECT * FROM tippek;
	DROP TABLE tippek;	

END//
DELIMITER ;


-------------------------------------------------------------------------------------------------------------------







DROP PROCEDURE IF EXISTS lottostatisztika;
DELIMITER //
CREATE PROCEDURE lottostatisztika()
BEGIN
	# DEKLARÁCIÓK
	-- 1. változók
	DECLARE i INT DEFAULT 1;
	DECLARE lsz INT;
	-- 2. a lekérdezésekhez kapcsolódó CURSOR-ok
	-- 3. kivételkezeléshez tartozó deklarációkat tartalmazza
	# DECLARE CONTINUE HANDLER FOR 1062 SET i=i-1;
	DECLARE CONTINUE HANDLER FOR 1062 SELECT "ugyanaz: ",lsz;
	-- FUNKCIONALITÁS
	CREATE TABLE tippek(szam INT PRIMARY KEY);
	# WHILE i<=5 DO
	WHILE (SELECT COUNT(*) FROM tippek)<5 DO
		SET lsz=FLOOR(RAND()*90+1);
		INSERT INTO tippek VALUES(lsz);
		# SET i=i+1;
	END WHILE;
	SELECT * FROM tippek;
	DROP TABLE tippek;	

END//
DELIMITER ;


Az olyan lekérdezés, amely egyetlen értéket szolgáltat eredményül, pl SELECT COUNT(*) FROM tippek; felhasználhatjuk értékadásban (SET), valamint feltétel megfogalmazások esetén, mint Sub-query-t/al-lekérdezést, a szükséges zárójelezéssel.

Ha a lekérdezés több értéket ad vissza, illetve több sort, akkor már a fenti megoldás nem alkalmazható. Ilyen esetben válik szükségessé a CURSOR, ami a lekérdezés eredményhalmazát, mint file-t veszi figyelembe és így garantálja a filekezelések során alkalmazott 
menetrendet:
- megnyitás
- olvasás (ameddig lehetséges)
- bezárás

A megnyitás (OPEN) hatására hajtódik végre a SELECT utasítással megfogalmazott lekérdezés, amelynek soraihoz az olvasást (FETCH) biztosítja, hogy végül a bezárást a CLOSE-zal végezhessük el.


Kurzor deklarálás:

DECLARE noveles CURSOR FOR SELECT * FROM tippek;
...
CREATE TABLE IF NOT EXISTS gyakorisagok(szam INT, db INT DEFAULT 0);
DELETE FROM gyakorisagok;
...
egy 1-től 90-ig lépegető ciklussal felvesszük 0 db-bal a lehetséges lottószámokat
...
OPEN noveles;
itt egy olyan ciklus működik, amely rendre veszi a tippek tábla 5 sorát
FETCH noveles INTO lsz;
UPDATE gyakorisagok SET db=db+1 WHERE szam=lsz;

végezetül: CLOSE noveles;





MySQL-ben létrehoztunk egy sppeldak adatbázist, jellemzően a tárolt eljárások/stored procedure készítésének kiprobálására.

Ebben van egy lottostatisztika elnevezésű tárolt eljárás (az adatbázishoz kapcsolódóan tárolodik a mysql rendszeradatbázis)


DROP PROCEDURE IF EXISTS lottostatisztika;
DELIMETER //
CREATE PROCEDURE lottostatisztika()
BEGIN
	# DEKLARÁCIÓK
	-- 1. változók
	DECLARE i INT DEFAULT 1;
	DECLARE lsz INT;
	-- 2. a lekérdezésekhez kapcsolódó CURSOR-ok
	-- 3. kivételkezeléshez tartozó deklarációkat tartalmazza
	# DECLARE CONTINUE HANDLER FOR 1062 SET i=i-1;
	DECLARE CONTINUE HANDLER FOR 1062 SELECT "ugyanaz: ",lsz;
	-- FUNKCIONALITÁS
	CREATE TABLE tippek(szam INT PRIMARY KEY);
	# WHILE i<=5 DO
	WHILE (SELECT COUNT(*) FROM tippek)<5 DO
		SET lsz=FLOOR(RAND()*90+1);
		INSERT INTO tippek VALUES(lsz);
		# SET i=i+1;
	END WHILE;
	SELECT * FROM tippek;
	DROP TABLE tippek;	

END//
DELIMETER;

A BEGIN után közvetlenül kell kerüljenek a DECLARE kulcsszóval megírt deklarációk. Ezek sorrendje is kötött:
1.) A változók deklarálása
2.) A SELECT utasítással megfogalmazható lekérdezésekhez kapcsoló mutatók/CURSOR-ok deklarálása
3.) A kivételek kezelésére szolgáló megoldások deklarálása a példánkban CONTINUE HANDLER a 1062-es "kulcsütközés" hiba bekövetkeztére.

Pillanatnyi programunk ltrehoz egy ideiglenes tippek nevű egyetlen szam elnevezésű mezőt tartalmazó táblát, amelyben ez a mező azért elsődleges kulcs, hogy kivédhessük az azonosságokat. A számok egymásután történő előállítása az lsz elnevezésű változóban történik, aminek aktuális értékét a tippek táblához próbáljuk hozzáadni. Ha a tippek táblában van 5 sor, akkor a ciklus befejeződik és kiirja azokat, majd törli a tippek nevezetű táblát.


A programunkat szeretnénk úgy kiteljesíteni, hogy kívülről, paraméterként határozhassk meg azt, hgy hány darab sorsolás kerüljön végrehajtásra. Az egyes sorsolásokután szeretnénk megállapítani, hogy melyik lottószám hányszor fordult elő összességében.

A lottószámok gyakoriságának megállapítása érdekében hozzunk létre egy pl. egy gyakorisagok(szam, db) táblát, amelyben 1-től, 90-ig szerepelnek a lottószámok, kezdetben 0 db értékkel, mivel egyiket sem sorsolták ki.
(Nem feltétlen szükséges minden táblánál elsődlege kulcs, ugyanis az csak indokolatlan területeket emészt fel a Bináris fa rendezési algoritmus adminisztrációja következtében.)

CREATE TABLE gyakorisagok(
	szam INT
	db INT DEFAULT 0);

Ebbe a táblába szükséseg felvenni a lehetséges lottószámokat(1-90)


DROP PROCEDURE IF EXISTS lottostatisztika;
DELIMITER //
CREATE PROCEDURE lottostatisztika(IN mennyi INT)
BEGIN
	
	DECLARE i INT DEFAULT 1;
	DECLARE lsz INT;
	DECLARE kesz INT DEFAULT 0;
	DECLARE noveles CURSOR FOR SELECT * FROM tippek;
	DECLARE CONTINUE HANDLER FOR 1062 SELECT "ugyanaz: ",lsz;
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET kesz=1;
	CREATE TABLE IF NOT EXISTS gyakorisagok(szam INT, db INT DEFAULT 0);
	DELETE FROM gyakorisagok;
	WHILE i<=90 DO
		INSERT INTO gyakorisagok(szam) VALUES(i);
		SET i=i+1;
	END WHILE;
	WHILE i<=mennyi DO
		CREATE TABLE tippek(szam INT PRIMARY KEY);
		WHILE (SELECT COUNT(*) FROM tippek)<5 DO
			SET lsz=FLOOR(RAND()*90+1);
			INSERT INTO tippek VALUES(lsz);
		END WHILE;
		OPEN noveles;
		ciklus: LOOP
			FETCH noveles INTO lsz;
			IF kesz THEN
				LEAVE ciklus;
			END IF;
			UPDATE gyakorisagok SET db=db+1 WHERE szam=lsz;
		END LOOP ciklus;
		CLOSE noveles;
		DROP TABLE tippek;
		SET i=i+1;
		SET kesz=0;
	END WHILE;
	SELECT * FROM gyakorisagok;	
END//
DELIMITER ;

A tarolt eljárás esetén 3 féle paramétert használhatunk:

IN -> csak bemenő adat
OUT -> olyan speciális eljárás esetében használatos, amikor valamilyen visszatérési értéket is szolgáltat
INOUT -> mindkét irányra alkalmas paraméter

DELETE FROM gykorisagok; -> ha létezne a tábla egy korábbi kísérlet adataival, akkor azokat szeretnénk megsemmisíteni.

(CALL eljárás(10); ilyenkor azt sejthetjük hogy a 10 szám egy IN típusú paraméterbe került) 




	













